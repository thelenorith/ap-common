"""
Unit tests for ap_common.metadata module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import pytest
from unittest.mock import patch
from ap_common.metadata import (
    get_metadata,
    enrich_metadata,
    get_filtered_metadata,
    filter_metadata,
)


class TestFilterMetadata:
    """Tests for filter_metadata function."""

    def test_basic_filtering(self):
        """Test basic metadata filtering."""
        data = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"},
            "file2.fits": {"type": "DARK", "camera": "Camera1"},
            "file3.fits": {"type": "LIGHT", "camera": "Camera2"},
        }
        filters = {"type": "LIGHT"}

        result = filter_metadata(data, filters)

        assert len(result) == 2
        assert "file1.fits" in result
        assert "file3.fits" in result
        assert "file2.fits" not in result

    def test_multiple_filters(self):
        """Test filtering with multiple criteria."""
        data = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1", "filter": "Ha"},
            "file2.fits": {"type": "LIGHT", "camera": "Camera1", "filter": "O3"},
            "file3.fits": {"type": "LIGHT", "camera": "Camera2", "filter": "Ha"},
        }
        filters = {"type": "LIGHT", "camera": "Camera1", "filter": "Ha"}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file1.fits" in result

    def test_filter_with_function(self):
        """Test filtering with a function."""
        data = {
            "file1.fits": {"exposureseconds": "60.0"},
            "file2.fits": {"exposureseconds": "120.0"},
            "file3.fits": {"exposureseconds": "300.0"},
        }
        filters = {"exposureseconds": lambda x: float(x) > 100}

        result = filter_metadata(data, filters)

        assert len(result) == 2
        assert "file2.fits" in result
        assert "file3.fits" in result
        assert "file1.fits" not in result

    def test_filter_with_int(self):
        """Test filtering with integer value."""
        data = {
            "file1.fits": {"exposureseconds": "60.0"},
            "file2.fits": {"exposureseconds": "120.0"},
        }
        filters = {"exposureseconds": 120}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file2.fits" in result

    def test_filter_with_float(self):
        """Test filtering with float value."""
        data = {"file1.fits": {"temp": "25.5"}, "file2.fits": {"temp": "30.0"}}
        filters = {"temp": 25.5}

        result = filter_metadata(data, filters)

        assert len(result) == 1
        assert "file1.fits" in result

    def test_filter_missing_key(self):
        """Test that missing filter key doesn't exclude entry."""
        data = {
            "file1.fits": {"type": "LIGHT"},
            "file2.fits": {"type": "LIGHT", "camera": "Camera1"},
        }
        filters = {"camera": "Camera1"}

        result = filter_metadata(data, filters)

        # file1.fits doesn't have camera, so it's treated as OK (included)
        # file2.fits has camera matching filter, so it's included
        # Both should be included when filter key is missing
        assert len(result) == 2
        assert "file1.fits" in result
        assert "file2.fits" in result

    def test_invalid_filter_data(self):
        """Test that invalid filter data raises exception."""
        data = {"file1.fits": {"type": "LIGHT"}}

        with pytest.raises(Exception, match="Invalid filter data"):
            filter_metadata(data, None)

        with pytest.raises(Exception, match="Invalid filter data"):
            filter_metadata(data, {})

    def test_filter_with_none_value(self):
        """Test that filter with None value raises exception."""
        data = {"file1.fits": {"type": "LIGHT"}}
        filters = {"type": None}

        with pytest.raises(Exception, match="has no value"):
            filter_metadata(data, filters)


class TestGetMetadata:
    """Tests for get_metadata function."""

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_basic_metadata_loading(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test basic metadata loading."""
        mock_get_filenames.return_value = ["file1.fits", "file2.fits"]
        mock_get_headers.side_effect = [
            {"filename": "file1.fits", "type": "LIGHT"},
            {"filename": "file2.fits", "type": "DARK"},
        ]
        mock_enrich.return_value = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "targetname": None,
            },
            "file2.fits": {
                "filename": "file2.fits",
                "type": "DARK",
                "targetname": None,
            },
        }

        result = get_metadata(["dir1"], profileFromPath=False)

        assert len(result) == 2
        assert "file1.fits" in result
        assert "file2.fits" in result

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_with_required_properties(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test loading with required properties."""
        mock_get_filenames.return_value = ["file1.fits"]
        mock_get_headers.return_value = {"filename": "file1.fits", "type": "LIGHT"}
        mock_enrich.return_value = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "targetname": None,
                "camera": None,
            }
        }

        result = get_metadata(
            ["dir1"], profileFromPath=False, required_properties=["camera"]
        )

        assert "camera" in result["file1.fits"]

    @patch("ap_common.metadata.get_filenames")
    @patch("ap_common.metadata.get_file_headers")
    @patch("ap_common.metadata.enrich_metadata")
    def test_targetname_always_required(
        self, mock_enrich, mock_get_headers, mock_get_filenames
    ):
        """Test that targetname is always added to required properties."""
        mock_get_filenames.return_value = ["file1.fits"]
        mock_get_headers.return_value = {"filename": "file1.fits"}
        mock_enrich.return_value = {
            "file1.fits": {"filename": "file1.fits", "targetname": None}
        }

        result = get_metadata(["dir1"], profileFromPath=False)

        assert "targetname" in result["file1.fits"]


class TestEnrichMetadata:
    """Tests for enrich_metadata function."""

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_fits_file(self, mock_get_fits):
        """Test enriching metadata for FITS file."""
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "camera": "Camera1",
            "targetname": "M42",
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        result = enrich_metadata(
            data, profileFromPath=False, required_properties=["type"]
        )

        assert result["file1.fits"]["type"] == "LIGHT"
        assert result["file1.fits"]["camera"] == "Camera1"
        assert result["file1.fits"]["targetname"] == "M42"

    @patch("ap_common.metadata.get_xisf_headers")
    def test_enrich_xisf_file(self, mock_get_xisf):
        """Test enriching metadata for XISF file."""
        mock_get_xisf.return_value = {"type": "LIGHT", "camera": "Camera1"}

        data = {"file1.xisf": {"filename": "file1.xisf", "type": None}}

        result = enrich_metadata(
            data, profileFromPath=False, required_properties=["type"]
        )

        assert result["file1.xisf"]["type"] == "LIGHT"

    def test_enrich_cr2_file(self):
        """Test enriching metadata for CR2 file."""
        data = {"file1.cr2": {"filename": "file1.cr2"}}

        # CR2 files only get enriched if required_properties are specified
        # Location is not available from CR2 file headers, so it must be provided
        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["latitude"],
            latitude="40.7128",
            longitude="-74.0060",
        )

        # CR2 files get latitude/longitude from provided parameters
        assert result["file1.cr2"]["latitude"] == "40.7128"
        assert result["file1.cr2"]["longitude"] == "-74.0060"

    def test_enrich_cr2_file_missing_location_error(self):
        """Test that enriching CR2 file without location raises error when required."""
        data = {"file1.cr2": {"filename": "file1.cr2"}}

        # CR2 files require location to be provided if it's in required_properties
        with pytest.raises(ValueError, match="Required property 'latitude' is missing"):
            enrich_metadata(
                data,
                profileFromPath=False,
                required_properties=["latitude"],
                # latitude and longitude not provided
            )

    def test_no_enrichment_needed(self):
        """Test that files with all properties don't need enrichment."""
        data = {
            "file1.fits": {
                "filename": "file1.fits",
                "type": "LIGHT",
                "camera": "Camera1",
                "targetname": "M42",
            }
        }

        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type", "camera", "targetname"],
        )

        # Should not call get_fits_headers if all properties present
        assert result["file1.fits"]["type"] == "LIGHT"

    def test_filename_always_set(self):
        """Test that filename is always set in result."""
        data = {"file1.fits": {"filename": "file1.fits", "type": "LIGHT"}}

        result = enrich_metadata(data, profileFromPath=False)

        assert result["file1.fits"]["filename"] == "file1.fits"

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_with_missing_profile_keys_and_print_status(self, mock_get_fits):
        """Test enriching metadata with printStatus=True but missing optic/focal_ratio/camera keys.

        This tests the fix for issue #13 - should not raise KeyError when profile keys are missing.
        """
        # Return enriched data that has targetname but is missing optic, focal_ratio, camera
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "targetname": "M42",
            # Deliberately missing: optic, focal_ratio, camera
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        # Should not raise KeyError even with printStatus=True
        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type"],
            printStatus=True,
        )

        assert result["file1.fits"]["type"] == "LIGHT"
        assert result["file1.fits"]["targetname"] == "M42"
        # Profile should be None when keys are missing
        assert result["file1.fits"]["profile"] is None

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_with_partial_profile_keys_and_print_status(self, mock_get_fits):
        """Test enriching with only some profile keys present (e.g., optic but no focal_ratio)."""
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "targetname": "M42",
            "optic": "Refractor",
            "camera": "Camera1",
            # Deliberately missing: focal_ratio
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        # Should not raise KeyError
        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type"],
            printStatus=True,
        )

        assert result["file1.fits"]["optic"] == "Refractor"
        assert result["file1.fits"]["camera"] == "Camera1"
        # Profile should be built from available keys
        assert result["file1.fits"]["profile"] == "Refractor+Camera1"

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_with_null_profile_keys_and_print_status(self, mock_get_fits):
        """Test enriching when profile keys exist but are None."""
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "targetname": "M42",
            "optic": "Refractor",
            "focal_ratio": None,  # Exists but is None
            "camera": "Camera1",
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        # Should not raise KeyError - None values should be handled gracefully
        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type"],
            printStatus=True,
        )

        assert result["file1.fits"]["focal_ratio"] is None
        # Profile should be built from available keys, skipping None values
        assert result["file1.fits"]["profile"] == "Refractor+Camera1"

    @patch("ap_common.metadata.get_fits_headers")
    def test_enrich_with_all_profile_keys_sets_profile(self, mock_get_fits):
        """Test that profile is correctly set when all keys are present."""
        mock_get_fits.return_value = {
            "type": "LIGHT",
            "targetname": "M42",
            "optic": "Refractor",
            "focal_ratio": "5.6",
            "camera": "Camera1",
        }

        data = {"file1.fits": {"filename": "file1.fits", "type": None}}

        result = enrich_metadata(
            data,
            profileFromPath=False,
            required_properties=["type"],
        )

        # Profile should be constructed correctly
        assert result["file1.fits"]["profile"] == "Refractor@f5.6+Camera1"


class TestGetFilteredMetadata:
    """Tests for get_filtered_metadata function."""

    @patch("ap_common.metadata.get_metadata")
    @patch("ap_common.metadata.filter_metadata")
    def test_basic_filtered_metadata(self, mock_filter, mock_get):
        """Test getting filtered metadata."""
        mock_get.return_value = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"},
            "file2.fits": {"type": "DARK", "camera": "Camera1"},
        }
        mock_filter.return_value = {
            "file1.fits": {"type": "LIGHT", "camera": "Camera1"}
        }

        result = get_filtered_metadata(
            ["dir1"], filters={"type": "LIGHT"}, profileFromPath=False
        )

        assert len(result) == 1
        assert "file1.fits" in result
        mock_get.assert_called_once()
        mock_filter.assert_called_once()

    @patch("ap_common.metadata.get_metadata")
    @patch("ap_common.metadata.filter_metadata")
    def test_filter_keys_added_to_required(self, mock_filter, mock_get):
        """Test that filter keys are added to required properties."""
        mock_get.return_value = {"file1.fits": {"type": "LIGHT"}}
        mock_filter.return_value = {"file1.fits": {"type": "LIGHT"}}

        get_filtered_metadata(
            ["dir1"],
            filters={"type": "LIGHT", "camera": "Camera1"},
            profileFromPath=False,
        )

        # Check that get_metadata was called with filter keys in required_properties
        call_args = mock_get.call_args
        assert "type" in call_args.kwargs["required_properties"]
        assert "camera" in call_args.kwargs["required_properties"]


class TestGroupByDirectory:
    """Tests for group_by_directory function."""

    def test_basic_grouping(self):
        """Test basic grouping by directory."""
        from ap_common.metadata import group_by_directory

        data = {
            "/path/dir1/file1.fits": {"type": "LIGHT"},
            "/path/dir1/file2.fits": {"type": "DARK"},
            "/path/dir2/file3.fits": {"type": "LIGHT"},
        }

        result = group_by_directory(data)

        assert len(result) == 2
        assert "/path/dir1" in result
        assert "/path/dir2" in result
        assert len(result["/path/dir1"]) == 2
        assert len(result["/path/dir2"]) == 1

    def test_empty_data(self):
        """Test grouping empty data."""
        from ap_common.metadata import group_by_directory

        result = group_by_directory({})

        assert result == {}

    def test_single_directory(self):
        """Test grouping files all in one directory."""
        from ap_common.metadata import group_by_directory

        data = {
            "/path/dir1/file1.fits": {"type": "LIGHT"},
            "/path/dir1/file2.fits": {"type": "DARK"},
            "/path/dir1/file3.fits": {"type": "FLAT"},
        }

        result = group_by_directory(data)

        assert len(result) == 1
        assert "/path/dir1" in result
        assert len(result["/path/dir1"]) == 3

    def test_nested_directories(self):
        """Test grouping files in nested directories."""
        from ap_common.metadata import group_by_directory

        data = {
            "/path/dir1/subdir/file1.fits": {"type": "LIGHT"},
            "/path/dir1/file2.fits": {"type": "DARK"},
        }

        result = group_by_directory(data)

        assert len(result) == 2
        assert "/path/dir1/subdir" in result
        assert "/path/dir1" in result


class TestGetDirectoriesWithLights:
    """Tests for get_directories_with_lights function."""

    def test_basic_light_detection(self):
        """Test detecting directories with light frames."""
        from ap_common.metadata import get_directories_with_lights

        data = {
            "/path/dir1/file1.fits": {"type": "LIGHT"},
            "/path/dir1/file2.fits": {"type": "DARK"},
            "/path/dir2/file3.fits": {"type": "DARK"},
            "/path/dir3/file4.fits": {"type": "LIGHT"},
        }

        result = get_directories_with_lights(data)

        assert len(result) == 2
        assert "/path/dir1" in result
        assert "/path/dir3" in result
        assert "/path/dir2" not in result

    def test_no_lights(self):
        """Test with no light frames."""
        from ap_common.metadata import get_directories_with_lights

        data = {
            "/path/dir1/file1.fits": {"type": "DARK"},
            "/path/dir2/file2.fits": {"type": "FLAT"},
        }

        result = get_directories_with_lights(data)

        assert len(result) == 0

    def test_empty_data(self):
        """Test with empty data."""
        from ap_common.metadata import get_directories_with_lights

        result = get_directories_with_lights({})

        assert len(result) == 0

    def test_case_insensitive(self):
        """Test that light detection is case insensitive."""
        from ap_common.metadata import get_directories_with_lights

        data = {
            "/path/dir1/file1.fits": {"type": "light"},
            "/path/dir2/file2.fits": {"type": "Light"},
            "/path/dir3/file3.fits": {"type": "LIGHT"},
        }

        result = get_directories_with_lights(data)

        assert len(result) == 3

    def test_missing_type(self):
        """Test files without type are not counted as lights."""
        from ap_common.metadata import get_directories_with_lights

        data = {
            "/path/dir1/file1.fits": {"camera": "Camera1"},
            "/path/dir2/file2.fits": {"type": "LIGHT"},
        }

        result = get_directories_with_lights(data)

        assert len(result) == 1
        assert "/path/dir2" in result


class TestGetCalibrationCandidates:
    """Tests for get_calibration_candidates function."""

    def test_basic_calibration_candidates(self):
        """Test finding calibration frames in light directories."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/light1.fits": {"type": "LIGHT"},
            "/path/dir1/dark1.fits": {"type": "DARK"},
            "/path/dir1/flat1.fits": {"type": "FLAT"},
            "/path/dir2/dark2.fits": {"type": "DARK"},
        }

        result = get_calibration_candidates(data)

        # Only calibration frames in directories with lights
        assert len(result) == 2
        assert "/path/dir1/dark1.fits" in result
        assert "/path/dir1/flat1.fits" in result
        assert "/path/dir2/dark2.fits" not in result

    def test_custom_light_directories(self):
        """Test with custom light directories."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/dark1.fits": {"type": "DARK"},
            "/path/dir2/dark2.fits": {"type": "DARK"},
        }

        result = get_calibration_candidates(data, light_directories={"/path/dir2"})

        assert len(result) == 1
        assert "/path/dir2/dark2.fits" in result

    def test_custom_calibration_types(self):
        """Test with custom calibration types."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/light1.fits": {"type": "LIGHT"},
            "/path/dir1/dark1.fits": {"type": "DARK"},
            "/path/dir1/flat1.fits": {"type": "FLAT"},
            "/path/dir1/bias1.fits": {"type": "BIAS"},
        }

        result = get_calibration_candidates(data, calibration_types=["DARK"])

        assert len(result) == 1
        assert "/path/dir1/dark1.fits" in result

    def test_master_calibration_frames(self):
        """Test that master calibration frames are also found."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/light1.fits": {"type": "LIGHT"},
            "/path/dir1/master_dark.fits": {"type": "MASTER DARK"},
            "/path/dir1/master_flat.fits": {"type": "MASTER FLAT"},
        }

        result = get_calibration_candidates(data)

        assert len(result) == 2
        assert "/path/dir1/master_dark.fits" in result
        assert "/path/dir1/master_flat.fits" in result

    def test_no_calibration_frames(self):
        """Test with no calibration frames."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/light1.fits": {"type": "LIGHT"},
            "/path/dir1/light2.fits": {"type": "LIGHT"},
        }

        result = get_calibration_candidates(data)

        assert len(result) == 0

    def test_empty_data(self):
        """Test with empty data."""
        from ap_common.metadata import get_calibration_candidates

        result = get_calibration_candidates({})

        assert len(result) == 0

    def test_case_insensitive(self):
        """Test that calibration type detection is case insensitive."""
        from ap_common.metadata import get_calibration_candidates

        data = {
            "/path/dir1/light1.fits": {"type": "LIGHT"},
            "/path/dir1/dark1.fits": {"type": "dark"},
            "/path/dir1/flat1.fits": {"type": "Flat"},
        }

        result = get_calibration_candidates(data)

        assert len(result) == 2
