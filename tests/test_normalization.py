"""
Unit tests for ap_common.normalization module.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import pytest
from ap_common.normalization import (
    normalize_filterName,
    normalize_date,
    normalize_datetime,
    normalize_target_name,
    normalize_headers,
    denormalize_header,
    normalize_filename,
    get_all_normalized_keys,
    get_normalized_keys_set,
)


class TestNormalizeFilterName:
    """Tests for normalize_filterName function.

    Note: Filter name transformations have been removed. The function
    now returns filter names unchanged.
    """

    def test_filter_returned_unchanged(self):
        """Test that filter names are returned unchanged."""
        assert normalize_filterName("BaaderUVIRCut") == "BaaderUVIRCut"
        assert normalize_filterName("OptolongLeXtreme") == "OptolongLeXtreme"
        assert normalize_filterName("S2") == "S2"
        assert normalize_filterName("Ha") == "Ha"
        assert normalize_filterName("O3") == "O3"
        assert normalize_filterName("") == ""
        assert normalize_filterName("UnknownFilter") == "UnknownFilter"
        assert normalize_filterName("L") == "L"
        assert normalize_filterName("R") == "R"
        assert normalize_filterName("G") == "G"
        assert normalize_filterName("B") == "B"


class TestNormalizeDate:
    """Tests for normalize_date function."""

    def test_standard_datetime(self):
        """Test standard datetime format."""
        # Use explicit timezone offset (EST -4) to make test deterministic
        # EST -4 - 12 = -16 hours total, so 12:30 - 16 = previous day
        result = normalize_date("2024-01-15T12:30:45", timezone_offset_from_gmt=-4.0)
        assert result == "2024-01-14"  # 12:30 - 16 hours = previous day

    def test_with_timezone_z(self):
        """Test datetime with Z timezone."""
        result = normalize_date("2024-01-15T12:30:45Z")
        assert isinstance(result, str)
        assert len(result) == 10  # YYYY-MM-DD format

    def test_with_timezone_offset(self):
        """Test datetime with timezone offset."""
        result = normalize_date("2024-01-15T12:30:45+00:00")
        assert isinstance(result, str)

    def test_with_fractional_seconds(self):
        """Test datetime with fractional seconds."""
        result = normalize_date("2024-01-15T12:30:45.123")
        assert isinstance(result, str)

    def test_date_only_format(self):
        """Test date-only format."""
        result = normalize_date("2024-01-15")
        assert result == "2024-01-15"

    def test_custom_formats(self):
        """Test with custom input and output formats."""
        # Use explicit timezone offset (EST -4) to make test deterministic
        # EST -4 - 12 = -16 hours total
        result = normalize_date(
            "15/01/2024",
            input_format="%d/%m/%Y",
            output_format="%Y-%m-%d",
            timezone_offset_from_gmt=-4.0,
        )
        # When parsed as datetime, subtracting 16 hours gives previous day
        assert result == "2024-01-14"  # Previous day due to 16-hour timezone offset

    def test_invalid_date(self):
        """Test invalid date returns original string."""
        result = normalize_date("invalid-date")
        assert result == "invalid-date"

    def test_timezone_offset_parameter(self):
        """Test timezone_offset_from_gmt parameter."""
        # UTC is 0, so total offset is 0 - 12 = -12 → stays on same day
        result_utc = normalize_date("2024-01-15T12:30:45", timezone_offset_from_gmt=0.0)
        # EST is -4, so total offset is -4 - 12 = -16 → previous day
        result_est = normalize_date(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=-4.0
        )
        # Positive timezone (e.g., +5 for India) would be +5 - 12 = -7 → same day
        result_positive = normalize_date(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=5.0
        )

        # UTC should stay on same day (2024-01-15), EST should be previous day (2024-01-14)
        assert result_utc == "2024-01-15"
        assert result_est == "2024-01-14"
        # Positive timezone should also stay on same day
        assert result_positive == "2024-01-15"
        # Verify they produce different results where expected
        assert result_utc != result_est
        assert result_positive != result_est

    def test_system_timezone_default(self):
        """Test that system timezone is used when timezone_offset_from_gmt is None."""
        # Test that calling without timezone uses system timezone (not hardcoded)
        result_with_none = normalize_date(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=None
        )
        result_without_param = normalize_date("2024-01-15T12:30:45")

        # Both should use system timezone and produce same result
        assert result_with_none == result_without_param


class TestNormalizeDatetime:
    """Tests for normalize_datetime function."""

    def test_standard_datetime(self):
        """Test standard datetime format."""
        # Use explicit timezone offset to make test deterministic
        # System timezone may vary, so use explicit EST (-4)
        result = normalize_datetime(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=-4.0
        )
        assert isinstance(result, str)
        assert "_" in result  # Should be YYYY-MM-DD_HH-MM-SS format
        assert "2024-01-14" in result  # Should be previous day with -16 hour offset

    def test_date_only_to_datetime(self):
        """Test date-only input converted to datetime."""
        result = normalize_datetime("2024-01-15")
        assert isinstance(result, str)
        assert "_" in result

    def test_with_timezone(self):
        """Test datetime with timezone."""
        result = normalize_datetime("2024-01-15T12:30:45Z")
        assert isinstance(result, str)

    def test_timezone_offset_parameter(self):
        """Test timezone_offset_from_gmt parameter for datetime."""
        # UTC is 0, so total offset is 0 - 12 = -12 → stays on same day
        result_utc = normalize_datetime(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=0.0
        )
        # EST is -4, so total offset is -4 - 12 = -16 → previous day
        result_est = normalize_datetime(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=-4.0
        )
        # Positive timezone (e.g., +5 for India) would be +5 - 12 = -7 → same day
        result_positive = normalize_datetime(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=5.0
        )

        # UTC should stay on same day, EST should be previous day
        assert "2024-01-15" in result_utc
        assert "2024-01-14" in result_est
        assert "2024-01-15" in result_positive
        # Verify they produce different results where expected
        assert result_utc != result_est
        assert result_positive != result_est

    def test_system_timezone_default(self):
        """Test that system timezone is used when timezone_offset_from_gmt is None."""
        # Test that calling without timezone uses system timezone (not hardcoded)
        result_with_none = normalize_datetime(
            "2024-01-15T12:30:45", timezone_offset_from_gmt=None
        )
        result_without_param = normalize_datetime("2024-01-15T12:30:45")

        # Both should use system timezone and produce same result
        assert result_with_none == result_without_param

    def test_custom_formats(self):
        """Test with custom formats."""
        result = normalize_datetime(
            "15/01/2024 12:30:45",
            input_format="%d/%m/%Y %H:%M:%S",
            output_format="%Y-%m-%d_%H-%M-%S",
        )
        assert isinstance(result, str)


class TestNormalizeTargetName:
    """Tests for normalize_target_name function."""

    def test_simple_target(self):
        """Test simple target name."""
        result = normalize_target_name("M42")
        assert result == ["M42", ""]

    def test_target_with_panel(self):
        """Test target name with panel."""
        result = normalize_target_name("M42 Panel 1")
        assert result == ["M42", "1"]

    def test_target_with_quotes(self):
        """Test target name with single quotes."""
        result = normalize_target_name("M'42")
        assert result == ["M42", ""]

    def test_target_with_panel_and_quotes(self):
        """Test target with panel and quotes."""
        result = normalize_target_name("M'42 Panel 2")
        assert result == ["M42", "2"]

    def test_no_panel_match(self):
        """Test target without panel pattern."""
        result = normalize_target_name("Some Target")
        assert result == ["Some Target", ""]


class TestNormalizeHeaders:
    """Tests for normalize_headers function."""

    def test_basic_normalization(self):
        """Test basic header normalization."""
        headers = {"FILTER": "Ha", "EXPOSURE": "60.0", "IMAGETYP": "light"}
        result = normalize_headers(headers)
        assert "filter" in result
        assert result["filter"] == "Ha"  # Filter names are now unchanged
        assert "exposureseconds" in result
        assert result["exposureseconds"] == "60.00"

    def test_date_obs_normalization(self):
        """Test DATE-OBS normalization."""
        headers = {"DATE-OBS": "2024-01-15T12:30:45"}
        result = normalize_headers(headers)
        assert "date" in result
        assert "datetime" in result

    def test_target_name_extraction(self):
        """Test target name panel extraction."""
        headers = {"OBJECT": "M42 Panel 1"}
        result = normalize_headers(headers)
        assert result["targetname"] == "M42"
        assert result["panel"] == "1"

    def test_constant_normalization(self):
        """Test constant normalization."""
        headers = {"camera": "DWARFIII"}
        result = normalize_headers(headers)
        assert result["focal_ratio"] == "4.3"
        assert result["type"] == "LIGHT"

    def test_lowercase_conversion(self):
        """Test that unknown headers are lowercased."""
        headers = {"UNKNOWN_HEADER": "value"}
        result = normalize_headers(headers)
        assert "unknown_header" in result
        assert result["unknown_header"] == "value"

    def test_multiple_normalizations(self):
        """Test multiple header normalizations."""
        headers = {
            "FILTER": "Ha",
            "EXPOSURE": "120.5",
            "CCD-TEMP": "25.0",
            "TELESCOP": "Refractor",
            "INSTRUME": "Camera1",
        }
        result = normalize_headers(headers)
        assert result["filter"] == "Ha"  # Filter names are now unchanged
        assert result["exposureseconds"] == "120.50"
        assert result["temp"] == "25.00"
        assert result["optic"] == "Refractor"
        assert result["camera"] == "Camera1"


class TestDenormalizeHeader:
    """Tests for denormalize_header function."""

    def test_denormalize_exposure(self):
        """Test denormalizing exposureseconds."""
        result = denormalize_header("exposureseconds")
        assert result in ["EXPOSURE", "EXPTIME", "EXP"]

    def test_denormalize_filter(self):
        """Test denormalizing filter."""
        result = denormalize_header("filter")
        assert result == "FILTER"

    def test_denormalize_unknown(self):
        """Test denormalizing unknown header."""
        result = denormalize_header("unknown_header")
        assert result is None


class TestNormalizeFilename:
    """Tests for normalize_filename function."""

    def test_bias_filename(self):
        """Test BIAS filename normalization."""
        headers = {
            "type": "BIAS",
            "optic": "Refractor",
            "camera": "Camera1",
            "date": "2024-01-15",
            "exposureseconds": "0.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "None",
        }
        result = normalize_filename("/output", "test.fits", headers)
        assert "BIAS" not in result  # Type not in path for bias
        assert "Refractor+Camera1" in result
        assert "2024-01-15" in result

    def test_dark_filename(self):
        """Test DARK filename normalization."""
        headers = {
            "type": "DARK",
            "optic": "Refractor",
            "camera": "Camera1",
            "date": "2024-01-15",
            "exposureseconds": "300.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "None",
        }
        result = normalize_filename("/output", "test.fits", headers)
        assert "Refractor+Camera1" in result
        assert "300.00" in result

    def test_light_filename(self):
        """Test LIGHT filename normalization."""
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            "camera": "Camera1",
            "focal_ratio": "5.6",
            "date": "2024-01-15",
            "exposureseconds": "120.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "Ha",
            "targetname": "M42",
        }
        result = normalize_filename(
            "/output", "test.fits", headers, statedir="10_Blink"
        )
        assert "Refractor@f5.6+Camera1" in result
        assert "10_Blink" in result
        assert "M42" in result
        assert "2024-01-15" in result

    def test_missing_required_header(self):
        """Test that missing required header raises exception."""
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            # Missing other required headers
        }
        with pytest.raises(Exception, match="missing required header"):
            normalize_filename("/output", "test.fits", headers)

    def test_with_settemp(self):
        """Test filename with set temperature."""
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            "camera": "Camera1",
            "focal_ratio": "5.6",
            "date": "2024-01-15",
            "exposureseconds": "120.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "Ha",
            "targetname": "M42",
            "settemp": "-10.00",
        }
        result = normalize_filename("/output", "test.fits", headers)
        assert "SETTEMP_-10.00" in result

    def test_with_optional_headers(self):
        """Test filename with optional headers like hfr, stars."""
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            "camera": "Camera1",
            "focal_ratio": "5.6",
            "date": "2024-01-15",
            "exposureseconds": "120.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "Ha",
            "targetname": "M42",
            "hfr": "2.5",
            "stars": "150",
        }
        result = normalize_filename("/output", "test.fits", headers)
        assert "HFR_2.5" in result
        assert "STARS_150" in result

    def test_light_filename_without_focal_ratio(self):
        """Test LIGHT filename when focal_ratio is missing.

        This tests the fix for issue #13 - should not raise KeyError when focal_ratio is missing.
        """
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            "camera": "Camera1",
            # Deliberately missing: focal_ratio
            "date": "2024-01-15",
            "exposureseconds": "120.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "Ha",
            "targetname": "M42",
        }
        result = normalize_filename("/output", "test.fits", headers)
        # Should use optic+camera format without focal_ratio
        assert "Refractor+Camera1" in result
        assert "@f" not in result  # No focal ratio in path
        assert "M42" in result

    def test_light_filename_with_null_focal_ratio(self):
        """Test LIGHT filename when focal_ratio exists but is None."""
        headers = {
            "type": "LIGHT",
            "optic": "Refractor",
            "camera": "Camera1",
            "focal_ratio": None,  # Exists but is None
            "date": "2024-01-15",
            "exposureseconds": "120.00",
            "datetime": "2024-01-15_12-30-45",
            "filter": "Ha",
            "targetname": "M42",
        }
        result = normalize_filename("/output", "test.fits", headers)
        # Should use optic+camera format without focal_ratio
        assert "Refractor+Camera1" in result
        assert "@f" not in result  # No focal ratio in path


class TestGetAllNormalizedKeys:
    """Tests for get_all_normalized_keys function."""

    def test_date_obs_returns_multiple_keys(self):
        """Test that DATE-OBS returns both date and datetime."""
        result = get_all_normalized_keys("DATE-OBS")
        assert "date" in result
        assert "datetime" in result
        assert len(result) == 2

    def test_single_key_mapping(self):
        """Test headers that map to single normalized key."""
        assert get_all_normalized_keys("FILTER") == ["filter"]
        assert get_all_normalized_keys("INSTRUME") == ["camera"]
        assert get_all_normalized_keys("TELESCOP") == ["optic"]

    def test_exposure_variants(self):
        """Test that different exposure headers all map to exposureseconds."""
        assert get_all_normalized_keys("EXPOSURE") == ["exposureseconds"]
        assert get_all_normalized_keys("EXPTIME") == ["exposureseconds"]
        assert get_all_normalized_keys("EXP") == ["exposureseconds"]

    def test_unknown_header_lowercased(self):
        """Test that unknown headers return lowercased version."""
        assert get_all_normalized_keys("UNKNOWN") == ["unknown"]
        assert get_all_normalized_keys("CustomHeader") == ["customheader"]


class TestGetNormalizedKeysSet:
    """Tests for get_normalized_keys_set function."""

    def test_single_header(self):
        """Test with single header."""
        headers = {"FILTER": "Ha"}
        result = get_normalized_keys_set(headers)
        assert "filter" in result

    def test_multiple_headers(self):
        """Test with multiple headers."""
        headers = {"FILTER": "Ha", "EXPOSURE": "60.0", "INSTRUME": "Camera1"}
        result = get_normalized_keys_set(headers)
        assert "filter" in result
        assert "exposureseconds" in result
        assert "camera" in result

    def test_date_obs_includes_both_keys(self):
        """Test that DATE-OBS contributes both date and datetime to the set."""
        headers = {"DATE-OBS": "2024-01-15T12:30:45"}
        result = get_normalized_keys_set(headers)
        assert "date" in result
        assert "datetime" in result
        assert len(result) == 2

    def test_conflicting_exposure_headers(self):
        """Test that EXPOSURE and EXPTIME both map to exposureseconds."""
        headers = {"EXPOSURE": "60.0", "EXPTIME": "60.0"}
        result = get_normalized_keys_set(headers)
        # Both map to same key, so should only appear once in set
        assert "exposureseconds" in result
        assert result == {"exposureseconds"}

    def test_mixed_headers_with_date_obs(self):
        """Test mixed headers including DATE-OBS."""
        headers = {
            "DATE-OBS": "2024-01-15T12:30:45",
            "FILTER": "Ha",
            "INSTRUME": "Camera1",
        }
        result = get_normalized_keys_set(headers)
        assert "date" in result
        assert "datetime" in result
        assert "filter" in result
        assert "camera" in result
        assert len(result) == 4
