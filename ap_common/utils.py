"""
Utility functions: environment variable replacement, string conversion, and file finding.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import re
import zipfile
from pathlib import Path


def build_profile(headers: dict) -> str | None:
    """
    Build a profile string from optic, focal_ratio, and camera headers.

    Args:
        headers: Dictionary containing header values

    Returns:
        Profile string built from available components:
        - Full: "Refractor@f5.6+Camera1"
        - No focal_ratio: "Refractor+Camera1"
        - No camera: "Refractor@f5.6"
        - Only optic: "Refractor"
        - Only camera: "Camera1"
        - Only focal_ratio: None (not useful alone)
        - Nothing available: None
    """
    optic = headers.get("optic")
    focal_ratio = headers.get("focal_ratio")
    camera = headers.get("camera")

    parts = []

    if optic:
        part = optic
        if focal_ratio:
            part = f"{part}@f{focal_ratio}"
        parts.append(part)

    if camera:
        parts.append(camera)

    if not parts:
        return None

    return "+".join(parts)


def replace_env_vars(input: str | None) -> str | None:
    """
    Replaces environment variable placeholders in a string with their actual values from the OS environment.

    Args:
        input: String that may contain environment variable placeholders like %VARNAME%

    Returns:
        String with environment variables replaced, or None if input is None
    """
    if input is None:
        return None
    output = input
    output_uc = input.upper()
    for e in os.environ.items():
        k = f"%{e[0]}%"
        v = e[1]
        while k in output_uc:
            # env vars are uppercase but ignore case when used.  use slices to do replacing.
            k_start = output_uc.find(k)
            output = output[:k_start] + v + output[k_start + len(k) :]
            output_uc = output.upper()
    return output


def resolve_path(path: str | None) -> str | None:
    """
    Resolve a path by expanding environment variables, user home directory, and converting to absolute path.

    This function performs comprehensive path resolution:
    1. Expands custom environment variables (e.g., %VARNAME%)
    2. Expands user home directory (e.g., ~)
    3. Converts to absolute path and resolves any relative components (e.g., .., .)

    Args:
        path: Path string that may contain environment variables, ~ for home, or relative components

    Returns:
        Fully resolved absolute path string, or None if input is None
    """
    if path is None:
        return None

    # Step 1: Replace custom environment variables (%VARNAME% style)
    resolved = replace_env_vars(path)
    if resolved is None:
        return None

    # Step 2: Expand user home directory (~)
    resolved = os.path.expanduser(resolved)

    # Step 3: Convert to absolute path and resolve relative components
    resolved = str(Path(resolved).resolve())

    return resolved


# https://stackoverflow.com/questions/8347048/how-to-convert-string-to-title-case-in-python
def camelCase(st: str) -> str:
    """
    Convert a string to camelCase, removing non-alphanumeric characters and capitalizing each word except the first.

    Args:
        st: String to convert

    Returns:
        camelCase string, or empty string if input has no alphanumeric characters
    """
    output = "".join(x for x in st.title() if x.isalnum())
    if not output:
        return ""
    return output[0].lower() + output[1:]


def get_filenames(
    dirs: list[str],
    patterns: list[str] | None = None,
    recursive: bool = False,
    zips: bool = False,
) -> list[str]:
    """
    Returns a list of filenames in the given directories matching the provided patterns.
    Supports recursive search and ZIP archive extraction.

    Args:
        dirs: List of directories to search
        patterns: List of regex patterns to match (defaults to [r".*[.]fits$"])
        recursive: Whether to search recursively
        zips: Whether to search inside ZIP files

    Returns:
        List of matching file paths
    """
    if patterns is None:
        patterns = [r".*\.fits$"]

    filenames = []
    for pattern in patterns:
        for dir in dirs:
            # Normalize path separators to OS-appropriate format
            resolved_dir = resolve_path(dir)
            if resolved_dir is None:
                continue
            if not recursive:
                for filename in os.listdir(resolved_dir):
                    filename_path = os.path.join(resolved_dir, filename)
                    # Check if it matches the pattern or is a zip file
                    if re.search(pattern, filename) or (
                        zips and zipfile.is_zipfile(filename_path)
                    ):
                        # found a matching file or found a zip file
                        if zips and zipfile.is_zipfile(filename_path):
                            # Process ZIP archive
                            with zipfile.ZipFile(filename_path, "r") as archive:
                                for zip_filename in (
                                    filename
                                    for filename in archive.filelist
                                    if re.search(pattern, filename.filename)
                                ):
                                    # add each contained filename that matches the pattern
                                    filenames.append(
                                        os.path.join(
                                            filename_path, zip_filename.filename
                                        )
                                    )
                        else:
                            # not a zip, simply add it
                            filenames.append(filename_path)
            else:
                for root, _, f_names in os.walk(resolved_dir):
                    for filename in (
                        filename for filename in f_names if re.search(pattern, filename)
                    ):
                        # special cases to ignore...
                        if "_stash" in root:
                            continue
                        filenames.append(os.path.join(root, filename))

    # Normalize all output paths to OS-appropriate format
    # Filter out None values in case resolve_path fails
    normalized_filenames = []
    for f in filenames:
        resolved = resolve_path(f)
        if resolved is not None:
            normalized_filenames.append(resolved)
    return normalized_filenames
