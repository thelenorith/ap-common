"""
FITS and XISF header reading and parsing functions.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import re
import xisf
from astropy.io import fits
from ap_common.normalization import (
    normalize_headers,
    get_normalized_key,
    get_normalized_keys_set,
    get_all_normalized_keys,
)
from ap_common.utils import replace_env_vars, resolve_path


def get_file_headers(
    filename: str,
    profileFromPath: bool,
    objectFromPath: bool = True,
    normalize: bool = True,
    directory_accept: str = None,
):
    """
    Extracts headers from a filename, optionally normalizing and extracting profile/object information from the path.
    Handles special cases for certain header keys and file types.

    Args:
        filename: Path to the file
        profileFromPath: Whether to extract profile (optic, focal ratio, camera) from path
        objectFromPath: Whether to extract object name from path
        normalize: Whether to normalize the headers
        directory_accept: The "accept" directory name to look for (project-specific, defaults to "accept")
    """
    # Normalize path separators to OS-appropriate format
    filename = resolve_path(filename)

    directory_accept = directory_accept or "accept"

    output = {
        "filename": filename,  # before any name manipulations
    }

    # SPECIAL CASES:
    # SET-TEMP: A key with a dash.  Thanks NINA.  Handle it before parsing by removing the dash.
    if "SET-TEMP" in filename:
        filename = filename.replace("SET-TEMP", "SETTEMP")

    # Hate special cases so it is optional.
    # Pick OBJECT from the path.  Is the beginning of the dir that is _parent_ of "accept".
    if objectFromPath and directory_accept in filename:
        # inject OBJECT_ at beginning of path before accept.
        # do this by splitting path and finding accept
        filename_split = filename.split(os.sep)
        filename_new = []
        for i in range(0, len(filename_split) - 1):
            icurr = filename_split[i]
            inext = filename_split[i + 1]
            if inext == directory_accept:
                filename_new.append(f"OBJECT_{icurr}")
            else:
                filename_new.append(icurr)
        filename_new.append(filename_split[-1])
        filename = os.sep.join(filename_new)

    # Pick Profile (optic, focal ratio, camera) from path.
    if profileFromPath:
        m = re.match(
            "(.*[\\\\\\/])([^@]*)@f([^+]*)[+]([^\\\\\\/]*)([\\\\\\/].*)", filename
        )
        if m and m.groups() and len(m.groups()) == 5:
            # rebuild path by injecting property prefixes
            p = m.groups()
            filename = f"{p[0]}TELESCOP_{p[1]}_FOCRATIO_{p[2]}_INSTRUME_{p[3]}{p[4]}"

    # just get the headers from the filename itself
    # don't be picky.  get EVERYTHING that could match
    for chunk in os.path.splitext(filename)[0].split(os.sep):
        m1 = re.split("[_]", chunk)
        for i in range(1, len(m1)):
            k = m1[i - 1]
            v = m1[i]
            if not str.isnumeric(k) and k not in output:
                output[k] = v
        for x in m1:
            if "-" in x:
                m2 = re.split("[-]", x)
                k = m2[0]
                v = "-".join(m2[1:])
                if not str.isnumeric(k) and k not in output and v is not None:
                    output[k] = v

    # SPECIAL CASES:
    # .CR2: If extension is .cr2 and TYPE is not already set, default TYPE to LIGHT
    if filename.endswith(".cr2") and "TYPE" not in output:
        output["TYPE"] = "LIGHT"

    # SET-TEMP: The dash was previously removed.  Add it back.
    if "SETTEMP" in output:
        output["SET-TEMP"] = output["SETTEMP"]

    # EXPOSURE: Value may end in "s", starting Dec 2023.  Thanks NINA.
    if "EXPOSURE" in output and "s" in output["EXPOSURE"]:
        output["EXPOSURE"] = output["EXPOSURE"].replace("s", "")

    if normalize:
        output = normalize_headers(output)

    return output


def get_fits_headers(
    filename: str,
    profileFromPath: bool,
    normalize: bool = True,
    file_naming_override: bool = False,
    directory_accept: str = None,
):
    """
    Extracts and normalizes FITS headers from a file, optionally overriding with headers from the filename.

    Args:
        filename: Path to the FITS file
        profileFromPath: Whether to extract profile from path
        normalize: Whether to normalize headers
        file_naming_override: Whether to override with headers from filename
        directory_accept: The "accept" directory name (project-specific)
    """
    # Normalize path separators to OS-appropriate format
    filename = resolve_path(filename)

    file_output = {}
    output = {}

    # Build a set of normalized keys from filename headers to detect conflicts
    # with FITS headers that use different raw keys but normalize to the same key
    # (e.g., filename has EXPOSURE but FITS has EXPTIME - both normalize to exposureseconds)
    normalized_keys_from_filename = set()

    if file_naming_override:
        # Don't normalize yet - use raw keys so filename headers properly
        # override FITS headers with the same raw keys during merge.
        # Normalization happens at the end after all headers are collected.
        file_output = get_file_headers(
            filename,
            normalize=False,
            profileFromPath=profileFromPath,
            directory_accept=directory_accept,
        )
        # Build set of normalized keys to detect conflicts
        normalized_keys_from_filename = get_normalized_keys_set(file_output)

    with fits.open(filename) as fits_file:
        # get all headers (key/value) as dict from primary image
        output = dict(fits_file[0].header)
    # convert all values to string
    for k in output:
        if output[k] is not None and not isinstance(output[k], str):
            output[k] = str(output[k])

    # Filter out FITS headers whose normalized form would conflict with filename headers
    # (e.g., remove EXPTIME if filename has EXPOSURE, since both → exposureseconds)
    # Only filter if ALL normalized keys from this header are provided by filename
    if normalized_keys_from_filename:
        filtered_output = {}
        for k, v in output.items():
            # Get all normalized keys this raw header produces
            normalized_keys = get_all_normalized_keys(k)
            # Only filter if ALL normalized keys are already in filename
            if not all(nk in normalized_keys_from_filename for nk in normalized_keys):
                filtered_output[k] = v
        output = filtered_output

    # file naming is higher priority but might be empty
    output = dict(list(output.items()) + list(file_output.items()))

    # normalize if required
    if normalize:
        output = normalize_headers(output)
    return output


def get_xisf_headers(
    filename: str,
    profileFromPath: bool,
    normalize: bool = True,
    file_naming_override: bool = False,
    directory_accept: str = None,
):
    """
    Extracts and normalizes XISF headers from a file, optionally overriding with headers from the filename.

    Args:
        filename: Path to the XISF file
        profileFromPath: Whether to extract profile from path
        normalize: Whether to normalize headers
        file_naming_override: Whether to override with headers from filename
        directory_accept: The "accept" directory name (project-specific)
    """
    # Normalize path separators to OS-appropriate format
    filename = resolve_path(filename)

    output = {}

    # Build a set of normalized keys from filename headers to detect conflicts
    # with XISF headers that use different raw keys but normalize to the same key
    # (e.g., filename has EXPOSURE but XISF has EXPTIME - both normalize to exposureseconds)
    normalized_keys_from_filename = set()

    if file_naming_override:
        # Don't normalize yet - we need raw keys to properly merge with XISF headers.
        # Normalization happens at the end after all headers are collected.
        output = get_file_headers(
            filename,
            normalize=False,
            profileFromPath=profileFromPath,
            directory_accept=directory_accept,
        )
        # Build set of normalized keys to detect conflicts
        normalized_keys_from_filename = get_normalized_keys_set(output)

    xisf_file = xisf.XISF(filename)
    metadata = xisf_file.get_images_metadata()
    # get all fits headers from metadata, converted to string
    for k in metadata[0]["FITSKeywords"].keys():
        # Skip HISTORY and keys that already exist (raw key match)
        if k in output or k == "HISTORY":
            continue
        # Skip keys whose normalized form would conflict with filename headers
        # (e.g., skip EXPTIME if filename already has EXPOSURE, since both → exposureseconds)
        # Only skip if ALL normalized keys from this header are provided by filename
        normalized_keys = get_all_normalized_keys(k)
        if all(nk in normalized_keys_from_filename for nk in normalized_keys):
            continue
        if (
            len(metadata[0]["FITSKeywords"][k]) > 0
            and "value" in metadata[0]["FITSKeywords"][k][0]
        ):
            v = metadata[0]["FITSKeywords"][k][0]["value"]
            if v is not None and str(v) != "":
                output[k] = str(v)
    # normalize if required
    if normalize:
        output = normalize_headers(output)
    return output
