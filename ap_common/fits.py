"""
FITS and XISF header reading and parsing functions.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import re
import xisf
from astropy.io import fits
from ap_common.normalization import normalize_headers
from ap_common.utils import replace_env_vars


def get_file_headers(
    filename: str,
    profileFromPath: bool,
    objectFromPath: bool = True,
    normalize: bool = True,
    directory_accept: str = None,
):
    """
    Extracts headers from a filename, optionally normalizing and extracting profile/object information from the path.
    Handles special cases for certain header keys and file types.

    Args:
        filename: Path to the file
        profileFromPath: Whether to extract profile (optic, focal ratio, camera) from path
        objectFromPath: Whether to extract object name from path
        normalize: Whether to normalize the headers
        directory_accept: The "accept" directory name to look for (project-specific, defaults to "accept")
    """
    directory_accept = directory_accept or "accept"

    output = {
        "filename": filename,  # before any name manipulations
    }

    # SPECIAL CASES:
    # SET-TEMP: A key with a dash.  Thanks NINA.  Handle it before parsing by removing the dash.
    if "SET-TEMP" in filename:
        filename = filename.replace("SET-TEMP", "SETTEMP")

    # Hate special cases so it is optional.
    # Pick OBJECT from the path.  Is the beginning of the dir that is _parent_ of "accept".
    if objectFromPath and directory_accept in filename:
        # inject OBJECT_ at beginning of path before accept.
        # do this by splitting path and finding accept
        filename_split = filename.split(os.sep)
        filename_new = []
        for i in range(0, len(filename_split) - 1):
            icurr = filename_split[i]
            inext = filename_split[i + 1]
            if inext == directory_accept:
                filename_new.append(f"OBJECT_{icurr}")
            else:
                filename_new.append(icurr)
        filename_new.append(filename_split[-1])
        filename = os.sep.join(filename_new)

    # Pick Profile (optic, focal ratio, camera) from path.
    if profileFromPath:
        m = re.match(
            "(.*[\\\\\\/])([^@]*)@f([^+]*)[+]([^\\\\\\/]*)([\\\\\\/].*)", filename
        )
        if m and m.groups() and len(m.groups()) == 5:
            # rebuild path by injecting property prefixes
            p = m.groups()
            filename = f"{p[0]}TELESCOP_{p[1]}_FOCRATIO_{p[2]}_INSTRUME_{p[3]}{p[4]}"

    # just get the headers from the filename itself
    # don't be picky.  get EVERYTHING that could match
    for chunk in os.path.splitext(filename)[0].split(os.sep):
        m1 = re.split("[_]", chunk)
        for i in range(1, len(m1)):
            k = m1[i - 1]
            v = m1[i]
            if not str.isnumeric(k) and k not in output:
                output[k] = v
        for x in m1:
            if "-" in x:
                m2 = re.split("[-]", x)
                k = m2[0]
                v = "-".join(m2[1:])
                if not str.isnumeric(k) and k not in output and v is not None:
                    output[k] = v

    # SPECIAL CASES:
    # .CR2: If extension is .cr2 and TYPE is not already set, default TYPE to LIGHT
    if filename.endswith(".cr2") and "TYPE" not in output:
        output["TYPE"] = "LIGHT"

    # SET-TEMP: The dash was previously removed.  Add it back.
    if "SETTEMP" in output:
        output["SET-TEMP"] = output["SETTEMP"]

    # EXPOSURE: Value may end in "s", starting Dec 2023.  Thanks NINA.
    if "EXPOSURE" in output and "s" in output["EXPOSURE"]:
        output["EXPOSURE"] = output["EXPOSURE"].replace("s", "")

    if normalize:
        output = normalize_headers(output)

    return output


def get_fits_headers(
    filename: str,
    profileFromPath: bool,
    normalize: bool = True,
    file_naming_override: bool = False,
    directory_accept: str = None,
):
    """
    Extracts and normalizes FITS headers from a file, optionally overriding with headers from the filename.

    Args:
        filename: Path to the FITS file
        profileFromPath: Whether to extract profile from path
        normalize: Whether to normalize headers
        file_naming_override: Whether to override with headers from filename
        directory_accept: The "accept" directory name (project-specific)
    """
    file_output = {}
    output = {}

    if file_naming_override:
        file_output = get_file_headers(
            filename,
            normalize=normalize,
            profileFromPath=profileFromPath,
            directory_accept=directory_accept,
        )

    with fits.open(filename) as fits_file:
        # get all headers (key/value) as dict from primary image
        output = dict(fits_file[0].header)
    # convert all values to string
    for k in output:
        if output[k] is not None and not isinstance(output[k], str):
            output[k] = str(output[k])

    # file naming is higher priority but might be empty
    output = dict(list(output.items()) + list(file_output.items()))

    # normalize if required
    if normalize:
        output = normalize_headers(output)
    return output


def get_xisf_headers(
    filename: str,
    profileFromPath: bool,
    normalize: bool = True,
    file_naming_override: bool = False,
    directory_accept: str = None,
):
    """
    Extracts and normalizes XISF headers from a file, optionally overriding with headers from the filename.

    Args:
        filename: Path to the XISF file
        profileFromPath: Whether to extract profile from path
        normalize: Whether to normalize headers
        file_naming_override: Whether to override with headers from filename
        directory_accept: The "accept" directory name (project-specific)
    """
    output = {}

    if file_naming_override:
        output = get_file_headers(
            filename,
            normalize=normalize,
            profileFromPath=profileFromPath,
            directory_accept=directory_accept,
        )

    xisf_file = xisf.XISF(filename)
    metadata = xisf_file.get_images_metadata()
    # get all fits headers from metadata, converted to string
    for k in metadata[0]["FITSKeywords"].keys():
        # don't overwrite any headers that already exist (only happens if loaded from filename)
        if k in output or k == "HISTORY":
            continue
        if (
            len(metadata[0]["FITSKeywords"][k]) > 0
            and "value" in metadata[0]["FITSKeywords"][k][0]
        ):
            v = metadata[0]["FITSKeywords"][k][0]["value"]
            if v is not None and str(v) != "":
                output[k] = str(v)
    # normalize if required
    if normalize:
        output = normalize_headers(output)
    return output
