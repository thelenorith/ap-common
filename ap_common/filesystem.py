"""
File operations: move, copy, and delete empty directories.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import shutil
from pathlib import Path
from ap_common.utils import replace_env_vars


def copy_file(from_file: str, to_file: str, debug: bool = False, dryrun: bool = False):
    """
    Copies a file from one location to another, creating directories as needed.
    Supports debug and dry run modes.

    Args:
        from_file: Source file path
        to_file: Destination file path
        debug: Print debug information
        dryrun: If True, don't actually copy the file
    """
    to_dir = os.sep.join(to_file.split(os.sep)[:-1])

    if debug:
        print(f"DEBUG: copy_file:\n    from_file={from_file},\n    to_file={to_file}")

    if not dryrun:
        # create new path
        Path(to_dir).mkdir(parents=True, exist_ok=True)

        # copy the file
        shutil.copy2(from_file, to_file)


def move_file(from_file: str, to_file: str, debug: bool = False, dryrun: bool = False):
    """
    Moves a file from one location to another, optionally printing debug info and supporting dry run mode.

    Args:
        from_file: Source file path
        to_file: Destination file path
        debug: Print debug information
        dryrun: If True, don't actually move the file
    """
    copy_file(
        from_file=from_file,
        to_file=to_file,
        debug=debug,
        dryrun=dryrun,
    )

    if debug:
        print(f"DEBUG: delete file after copy in move_file:\n    from_file={from_file}")

    if not dryrun:
        # then delete old file
        os.remove(from_file)


def delete_empty_directories(root_dir: str, dryrun: bool = False):
    """
    Recursively deletes empty directories under the given root directory.
    Supports dry run mode.

    Args:
        root_dir: Root directory to start deletion from
        dryrun: If True, don't actually delete directories
    """
    root_dir = replace_env_vars(root_dir)
    print(f"delete_empty_directories({root_dir})")
    done = False
    while not done and not dryrun:
        done = True
        # Collect all directories first, then delete in reverse order (bottom-up)
        dirs_to_check = []
        for root, d_names, f_names in os.walk(root_dir, topdown=False):
            for d in d_names:
                dir_path = os.path.join(root, d)
                dirs_to_check.append(dir_path)

        # Try to delete each directory
        for dir_path in dirs_to_check:
            try:
                os.rmdir(dir_path)
                done = False  # parent may need deleted
            except OSError:
                # ignore if cannot delete dir, means it is not empty.  this is OK.
                pass
