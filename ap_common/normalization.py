"""
Header normalization functions and data dictionaries.

Generated By: Cursor (Claude Sonnet 4.5)
"""

import os
import re
from datetime import datetime, timedelta, timezone
from typing import Any, Callable

from ap_common.utils import build_profile

# Date/datetime format constants
# These can be overridden by projects that need different formats
INPUT_FORMAT_DATETIME = r"%Y-%m-%dT%H:%M:%S"
OUTPUT_FORMAT_DATE = r"%Y-%m-%d"
OUTPUT_FORMAT_DATETIME = r"%Y-%m-%d_%H-%M-%S"


def _get_timezone_offset_from_gmt(timezone_offset_from_gmt: float = None) -> float:
    """
    Gets the timezone offset from GMT in hours.
    If not provided, uses the system's current timezone offset.

    Args:
        timezone_offset_from_gmt: Optional timezone offset from GMT in hours.
            If None, uses the system's current timezone offset.

    Returns:
        Timezone offset from GMT in hours as a float.
    """
    if timezone_offset_from_gmt is None:
        # Get current system timezone offset from GMT in hours
        local_tz_offset = datetime.now(timezone.utc).astimezone().utcoffset()
        if local_tz_offset is None:
            return 0.0
        return local_tz_offset.total_seconds() / 3600.0
    return timezone_offset_from_gmt


# Hardcoded -12 hours offset for middle-of-night date calculation.
# This adjusts observation times so that observations taken before midnight
# are grouped with the same observing "night" as those taken after midnight.
MIDNIGHT_OFFSET_HOURS = -12.0


def _prepare_date_string(date: str) -> str:
    """
    Prepares a date string for parsing by removing timezone info and fractional seconds.

    This function handles various date string formats that may include:
    - Timezone indicators (Z, +HH:MM, -HH:MM)
    - Fractional seconds (.123456)

    Args:
        date: Date string to prepare

    Returns:
        Cleaned date string ready for parsing
    """
    date_str = date

    # Remove timezone info if present (everything after the last 'Z' or '+'/'-')
    if "Z" in date_str or "+" in date_str or date_str.count("-") > 2:
        # Keep only the date and time part
        parts = date_str.split("Z")[0].split("+")[0].split("-", 3)[0:3]
        if isinstance(parts, list):
            date_str = "-".join(parts[:3])
        else:
            date_str = parts

    # Handle fractional seconds by truncating to whole seconds
    if "." in date_str:
        date_str = date_str.split(".")[0]

    return date_str


def normalize_filterName(name: str) -> str:
    """
    Returns the filter name unchanged.

    This function previously normalized filter names to short forms,
    but those transformations have been removed as they were specific
    to certain filter configurations that are no longer in use.
    """
    return name


def normalize_date(
    date: str,
    input_format: str | None = None,
    output_format: str | None = None,
    timezone_offset_from_gmt: float | None = None,
) -> str:
    """
    Converts a date string to the standard output date format, adjusting for timezone offset.
    The timezone offset is calculated as: timezone_offset_from_gmt - 12 hours.
    The -12 hours is hardcoded to adjust for middle-of-night date calculation.

    Args:
        date: Date string to normalize
        input_format: Optional input format override (defaults to INPUT_FORMAT_DATETIME)
        output_format: Optional output format override (defaults to OUTPUT_FORMAT_DATE)
        timezone_offset_from_gmt: Timezone offset from GMT in hours (e.g., -4 for EST, -5 for EDT).
            If None, uses the system's current timezone offset.
            Total offset applied will be: timezone_offset_from_gmt - 12
    """
    input_fmt = input_format or INPUT_FORMAT_DATETIME
    output_fmt = output_format or OUTPUT_FORMAT_DATE

    # Get timezone offset (system default if not provided)
    tz_offset = _get_timezone_offset_from_gmt(timezone_offset_from_gmt)
    total_offset_hours = tz_offset + MIDNIGHT_OFFSET_HOURS

    # Prepare date string for parsing
    date_str = _prepare_date_string(date)

    # Try to parse as datetime first, then as date-only if that fails
    try:
        parsed_date = datetime.strptime(date_str, input_fmt)
        adjusted_date = parsed_date + timedelta(hours=total_offset_hours)
    except ValueError:
        # If datetime parsing fails, try date-only format
        try:
            parsed_date = datetime.strptime(date_str, output_fmt)
            # For date-only, don't apply timezone offset since there's no time component
            adjusted_date = parsed_date
        except ValueError:
            # If both fail, return the original string
            return date_str

    return datetime.strftime(adjusted_date, output_fmt)


def normalize_datetime(
    date: str,
    input_format: str | None = None,
    output_format: str | None = None,
    timezone_offset_from_gmt: float | None = None,
) -> str:
    """
    Converts a date string to the standard output datetime format.
    The timezone offset is calculated as: timezone_offset_from_gmt - 12 hours.
    The -12 hours is hardcoded to adjust for middle-of-night date calculation.

    Args:
        date: Date string to normalize
        input_format: Optional input format override (defaults to INPUT_FORMAT_DATETIME)
        output_format: Optional output format override (defaults to OUTPUT_FORMAT_DATETIME)
        timezone_offset_from_gmt: Timezone offset from GMT in hours (e.g., -4 for EST, -5 for EDT).
            If None, uses the system's current timezone offset.
            Total offset applied will be: timezone_offset_from_gmt - 12
    """
    input_fmt = input_format or INPUT_FORMAT_DATETIME
    output_fmt = output_format or OUTPUT_FORMAT_DATETIME

    # Get timezone offset (system default if not provided)
    tz_offset = _get_timezone_offset_from_gmt(timezone_offset_from_gmt)
    total_offset_hours = tz_offset + MIDNIGHT_OFFSET_HOURS

    # Prepare date string for parsing
    date_str = _prepare_date_string(date)

    # Try to parse as datetime first, then as date-only if that fails
    try:
        parsed_date = datetime.strptime(date_str, input_fmt)
        adjusted_date = parsed_date + timedelta(hours=total_offset_hours)
    except ValueError:
        # If datetime parsing fails, try date-only format
        try:
            parsed_date = datetime.strptime(date_str, OUTPUT_FORMAT_DATE)
            # For date-only, set time to midnight
            parsed_date = parsed_date.replace(hour=0, minute=0, second=0)
            adjusted_date = parsed_date
        except ValueError:
            # If both fail, return the original string
            return date_str

    return datetime.strftime(adjusted_date, output_fmt)


def normalize_target_name(input: str) -> list[str]:
    """
    Splits a target name into the main target and panel if present, removing single quotes.
    Returns a list [target, panel].
    """
    target = input
    panel = ""
    m = re.match("(.*) Panel (.*)", target)
    if m is not None and m.groups() is not None and len(m.groups()) == 2:
        target = m.groups()[0]
        panel = m.groups()[1]
    else:
        panel = ""
    # strip single quote
    target = target.replace("'", "")
    return [target, panel]


def normalize_headers(
    input: dict, timezone_offset_from_gmt: float | None = None
) -> dict:
    """
    Normalizes a dictionary of headers using FILTER_NORMALIZATION_DATA and CONSTANT_NORMALIZATION_DATA.
    Converts keys to lower case if not found in normalization data.
    Handles special cases for target name and constants.

    Args:
        input: Dictionary of headers to normalize
        timezone_offset_from_gmt: Optional timezone offset from GMT in hours (e.g., -4 for EST).
            If None, uses the system's current timezone offset.
            This is passed to normalize_date() and normalize_datetime() functions.
    """
    output: dict[str, str] = {}
    for key in input.keys():
        value = input[key]
        if value is not None and key in FILTER_NORMALIZATION_DATA.keys():
            norm_data = FILTER_NORMALIZATION_DATA[key]
            for normalized_keyword in norm_data:
                # For date/datetime normalization, pass timezone if provided
                if key == "DATE-OBS" and normalized_keyword in ["date", "datetime"]:
                    if normalized_keyword == "date":
                        output[normalized_keyword] = normalize_date(
                            value, timezone_offset_from_gmt=timezone_offset_from_gmt
                        )
                    elif normalized_keyword == "datetime":
                        output[normalized_keyword] = normalize_datetime(
                            value, timezone_offset_from_gmt=timezone_offset_from_gmt
                        )
                else:
                    conversion_function = norm_data[normalized_keyword]
                    output[normalized_keyword] = conversion_function(value)
        else:
            # simply convert to lower case
            output[key.lower()] = value
    # final special case, strip panel out of target name
    if "panel" not in output and "targetname" in output and output["targetname"]:
        x = normalize_target_name(output["targetname"])
        output["targetname"] = x[0]
        output["panel"] = x[1]
    # handle constants
    for key in CONSTANT_NORMALIZATION_DATA.keys():
        const_data = CONSTANT_NORMALIZATION_DATA[key]
        for value in const_data.keys():
            if key in output and output[key] == value:
                const_values = const_data[value]
                for ckey in const_values.keys():
                    cvalue = const_values[ckey]
                    if ckey not in output:
                        output[ckey] = cvalue
    return output


def get_normalized_key(raw_key: str) -> str:
    """
    Returns the normalized key name for a raw header key.

    This is used to detect when two different raw keys (e.g., EXPOSURE and EXPTIME)
    would normalize to the same key (e.g., exposureseconds), which helps prevent
    duplicate/conflicting values during header merging.

    Args:
        raw_key: The raw header key (e.g., "EXPOSURE", "EXPTIME", "FILTER")

    Returns:
        The normalized key name (e.g., "exposureseconds", "filter") or the
        lowercase version of the key if not found in normalization data.
    """
    if raw_key in FILTER_NORMALIZATION_DATA:
        # Return the first (and typically only) normalized key for this raw key
        return list(FILTER_NORMALIZATION_DATA[raw_key].keys())[0]
    else:
        # Keys not in normalization data are simply lowercased
        return raw_key.lower()


def get_all_normalized_keys(raw_key: str) -> list[str]:
    """
    Returns all normalized key names that a raw header key maps to.

    For example, DATE-OBS maps to both 'date' and 'datetime'.

    Args:
        raw_key: The raw FITS header key

    Returns:
        List of all normalized keys this raw key produces, or [raw_key.lower()] if not in normalization data
    """
    if raw_key in FILTER_NORMALIZATION_DATA:
        return list(FILTER_NORMALIZATION_DATA[raw_key].keys())
    else:
        return [raw_key.lower()]


def get_normalized_keys_set(headers: dict) -> set:
    """
    Returns a set of normalized key names from a dictionary of raw headers.

    This is used to quickly check if adding a new raw key would create a conflict
    with existing headers after normalization (e.g., if headers already has EXPOSURE,
    adding EXPTIME would conflict since both normalize to exposureseconds).

    Args:
        headers: Dictionary of raw headers

    Returns:
        Set of normalized key names
    """
    result = set()
    for k in headers.keys():
        result.update(get_all_normalized_keys(k))
    return result


def denormalize_header(header: str) -> str | None:
    """
    Converts a normalized header name back to its original FITS header form if possible.
    Uses get_normalized_key() internally for consistent key mapping.
    """
    for raw_key in FILTER_NORMALIZATION_DATA.keys():
        if get_normalized_key(raw_key) == header:
            return raw_key

    # didn't find it..
    return None


def normalize_filename(
    output_directory: str,
    input_filename: str,
    headers: dict,
    statedir: str | None = None,
) -> str:
    """
    Constructs a normalized filename based on output directory, input filename, headers, and state directory.
    Ensures required headers are present and builds a path with relevant metadata.
    """
    file_extension = os.path.splitext(input_filename)[1]

    # the absolute bare minimum required headers
    required_headers = [
        "type",
        "optic",
        "camera",
        "date",
        "exposureseconds",
        "datetime",
        "filter",
    ]

    # check that all required headers are available.
    for rh in required_headers:
        if rh not in headers:
            raise Exception(
                f"missing required header '{rh}' for file: {input_filename}"
            )

    # collect output as an array.  will join it at the end
    output = [output_directory]
    type = headers["type"]

    if type == "BIAS" or type == "DARK" or type == "FLAT":
        # technically we care about focal ratio for flats
        # BUT this is used to repair raw data which does not include focal ratio
        # so we leave focal ratio out for flats.
        output.append(f"{headers['optic']}+{headers['camera']}")
    elif type == "LIGHT":
        # Use build_profile for consistent profile string construction
        profile = build_profile(headers)
        if profile is None:
            raise Exception(
                f"Cannot build profile from headers for file: {input_filename}"
            )
        output.append(profile)

    if type == "LIGHT":
        if statedir is not None and len(statedir) > 0:
            output.append(statedir)
        try:
            # if there is no targetname this may be a snapshot.  ignore it and move on.
            output.append(headers["targetname"])
        except KeyError as e:
            print(
                f"WARNING: missing targetname for LIGHT file, perhaps is a snapshot file: {input_filename}"
            )
            print(f"WARNING: {headers}")
            raise e

    # for all types...
    output.append(f"DATE_{headers['date']}")

    # while we don't care about filter for bias and darks, it is used generally included out of NINA
    p = f"FILTER_{headers['filter']}_EXP_{headers['exposureseconds']}"
    if "settemp" in headers:
        p = f"{p}_SETTEMP_{headers['settemp']}"
    if type == "LIGHT":
        if (
            "panel" in headers
            and headers["panel"] is not None
            and len(headers["panel"]) > 0
        ):
            p += f"_PANEL_{headers['panel']}"
    output.append(p)

    # for all types...
    p = f"{headers['datetime']}"
    for opt in ["hfr", "stars", "rmsac", "temp"]:
        if opt in headers and headers[opt] is not None and len(headers[opt]) > 0:
            p += f"_{opt.upper()}_{headers[opt]}"
    p += f"{file_extension}"
    output.append(p)

    # create the output filename
    output_filename = os.path.normpath(os.sep.join(output))

    return output_filename


# Normalization data dictionaries
# These must be defined after the normalization functions since they reference them

CONSTANT_NORMALIZATION_DATA: dict[str, dict[str, dict[str, str]]] = {
    "camera": {
        "DWARFIII": {
            "focal_ratio": "4.3",
            "type": "LIGHT",
        }
    }
}

FILTER_NORMALIZATION_DATA: dict[str, dict[str, Callable[[Any], str]]] = {
    "DATE-OBS": {
        "date": (lambda x: normalize_date(x)),
        "datetime": (lambda x: normalize_datetime(x)),
    },
    "FILTER": {"filter": (lambda x: normalize_filterName(x))},
    "EXPOSURE": {  # preferred key for exposureseconds
        "exposureseconds": (lambda x: "{:.2f}".format(float(x)))
    },
    "EXPTIME": {"exposureseconds": (lambda x: "{:.2f}".format(float(x)))},
    "EXP": {"exposureseconds": (lambda x: "{:.2f}".format(float(x)))},
    "CCD-TEMP": {"temp": (lambda x: "{:.2f}".format(float(x)))},
    "SETTEMP": {  # preferred key for settemp
        "settemp": (lambda x: "{:.2f}".format(float(x)))
    },
    "SET-TEMP": {"settemp": (lambda x: "{:.2f}".format(float(x)))},
    "IMAGETYP": {"type": (lambda x: str(x).upper())},
    "TELESCOP": {"optic": str},
    "FOCRATIO": {"focal_ratio": str},
    "INSTRUME": {"camera": str},
    "OBJECT": {"targetname": str},
    "SITELAT": {  # preferred key for latitude
        "latitude": (lambda x: "{0:.1f}".format(float(x)))
    },
    "OBSGEO-B": {"latitude": (lambda x: "{0:.1f}".format(float(x)))},
    "SITELONG": {  # preferred key for longitude
        "longitude": (lambda x: "{0:.1f}".format(float(x)))
    },
    "OBSGEO-L": {"longitude": (lambda x: "{0:.1f}".format(float(x)))},
    "READOUTM": {"readoutmode": str},
}
